---
// Import the necessary CSS for AG Grid
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-quartz.css';

---
<style>
  .ag-theme-quartz {
    font-family: monospace;
    --ag-background-color: #f5f5f4;
    --ag-header-background-color: white;
    --ag-odd-row-background-color: white;
    --good-color: #B9F6CE;    
    --bad-color: #FDC9C9;
  }

  .ag-theme-quartz-dark {
    font-family: monospace;
    --ag-background-color: #27272a;
    --ag-header-background-color: #3f3f46;
    --ag-odd-row-background-color: #3f3f46;
    --good-color: #15803d;
    --bad-color: #b91c1c;
  }

  .good {
    background-color: var(--good-color);
  }
  .bad {
    background-color: var(--bad-color);
  }

  @media (max-width: 640px) {
  #legend {
    display: none;
  }
}
</style>

<form id="benchmarks" class="text-sm">
  <div class="flex flex-row justify-between">
    <div class="flex flex-col">
      <label for="regionSelector" class="text-base font-bold" >Select a Region</label>
      <label class="text-base font-bold" >===============</label>
      <div id="regionSelector" class="my-4 flex flex-col">
        <div>
          <input type="radio" id="seaRegionSelector" name="selectedRegion" value="sea" checked />
          <label for="seaRegionSelector">US West (Seattle)</label>
        </div>
        <div>
          <input type="radio" id="iadRegionSelector" name="selectedRegion" value="iad" />
          <label for="iadRegionSelector">US East (Virginia)</label>
        </div>
        <div>
          <input type="radio" id="cdgRegionSelector" name="selectedRegion" value="cdg" />
          <label for="cdgRegionSelector">Europe (Paris)</label>
        </div>
      </div>
    </div>
    <div id="legend" class="mt-10 mb-4 text-left flex flex-col">
      <div><span class="font-bold">TTFT:</span> Time To First Token</div>
      <div><span class="font-bold">TPS: </span>Tokens Per Second</div>
      <div><span class="font-bold">Total Time: </span>From request to final token</div>
    </div>
  </div>

  
  <div id="myGrid" class="ag-theme-quartz text-sm bg-stone-100 font-mono text-gray-950 dark:bg-stone-900 dark:text-white w-full"></div>
  <div id="myFooter" class="ag-theme-quartz mt-4 flex flex-row justify-between text-sm items-center">
    <div>
      <p class="inline-flex">
        <div class="inline-flex items-center"><span class="good text-center rounded-md px-2 py-1 text-sm ring-1 ring-inset ring-gray-500/10 w-14">Green</span><span>&nbsp;= fastest,</span></div>
        <div class="inline-flex items-center"><span class="bad text-center rounded-md px-2 py-1 text-sm ring-1 ring-inset ring-gray-500/10 w-14">Red</span><span>&nbsp;= slowest.</span></div>
      </p>
    </div>
    <div id="lastUpdated" class=" font-mono italic text-right"></div>
  </div>
</form>

<script>
  import { createGrid } from 'ag-grid-community';
  import { BenchmarkRegions, gridOptionsBase, TTFTDefinition, TPSDefinition, TotalTimeDefinition } from '@/utils/DataGridDefinitions.ts';
  import { fetchLocalJsonFile } from '@/utils/FetchData.ts';

  let gridApi;
  const localData = '../../data/latest.json';
  const gridData = await fetchLocalJsonFile(localData);
  let selectedRegion = 'sea';
  let selectedRegionData = [];
  
  function updateRegion(region: string) {
    selectedRegion = region;
    gridData.forEach((regionData) => {
      if (regionData.region === region) {
        selectedRegionData = regionData.results;
        gridApi.setGridOption("rowData", selectedRegionData);
      }
    });
  };

  // Returns the background color for the cell based on the value
  function colFunction(params) {
    const currentColumnID = params.column.colId;
    const myGrid = document.getElementById('myGrid');
    const style = getComputedStyle(myGrid!);
    const map = {
      "ttft": TTFTDefinition,
      "tps": TPSDefinition,
      "total_time": TotalTimeDefinition
    };
    const def = map[currentColumnID];
    if (def) {
      const isGood = def.worstPerformance > def.bestPerformance ?
          params.value < def.bestPerformance : params.value > def.bestPerformance;
      const isBad = def.worstPerformance > def.bestPerformance ?
          params.value > def.worstPerformance : params.value < def.worstPerformance;
      if (isGood) {
        return { backgroundColor: style.getPropertyValue('--good-color') };
      } else if (isBad) {
        return { backgroundColor: style.getPropertyValue('--bad-color') };
      }
    }
    return {};
  }

  async function onDOMContentLoaded() {
    // setup the grid after the page has finished loading
    const gridDiv = document.querySelector("#myGrid") as HTMLElement;
    const gridOptions = gridOptionsBase;
    const isMobile = window.matchMedia('(max-width: 640px)').matches;
    // remove TTFT and TPS columns on mobile
    if (isMobile) {
      gridOptions.columnDefs.splice(2, 2);
    }
    gridOptions.columnDefs.forEach((columnDef) => {
      columnDef.cellStyle = colFunction;
    });
    
    gridApi = createGrid(gridDiv, gridOptions);
    updateRegion(selectedRegion);   // default to sea region on load

    // Add text for our last updated date
    const ourDiv = document.getElementById('lastUpdated');
    // ourDiv.classList.add('text-base', 'font-mono', 'italic', 'text-right');
    ourDiv!.innerText = `Last Updated: ${gridData[0].time.split('T')[0]}`;

    // Add an event listener to the radio buttons to filter the grid data
    document.getElementById('benchmarks')!.addEventListener('change', function(event) {
      // Filter the grid data based on the selected region
      if (event.target.name === 'selectedRegion') {
        updateRegion(event.target.value);
      }
    });
  }

  if (document.readyState === "loading") {
      // The document is still loading, add the event listener normally
      document.addEventListener("DOMContentLoaded", onDOMContentLoaded);
  } else {
      // The DOMContentLoaded event has already fired, call the function directly
      onDOMContentLoaded();
  }

  // Watch for dark mode changes and refresh the grid accordingly
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.attributeName === 'class') {        
        gridApi.refreshCells({ force: true });      
      }
    });
  });
  observer.observe(document.documentElement, { attributes: true });
</script>
